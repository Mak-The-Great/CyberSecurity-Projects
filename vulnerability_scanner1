import tkinter as tk
from tkinter import scrolledtext, messagebox, filedialog
import nmap
import csv
import datetime
import threading
import time
from plyer import notification  # Importing plyer for notifications
import ipaddress

def scan_target():
    ip_range = ip_entry.get().strip()
    if not ip_range:
        result_text.insert(tk.END, "Please enter a valid IP range.\n")
        return

    result_text.delete(1.0, tk.END)  # Clear previous results
    result_text.insert(tk.END, f"\nStarting scan on target range: {ip_range}...\n")

    # Create an instance of PortScanner
    nm = nmap.PortScanner()

    scan_results = {
        'host': [],
        'status': [],
        'os': [],
        'protocols': [],
        'ports': []
    }

    try:
        # Define IP range
        ip_network = ipaddress.ip_network(ip_range, strict=False)
        for ip in ip_network.hosts():
            target_ip = str(ip)
            result_text.insert(tk.END, f"\nScanning: {target_ip}...\n")
            nm.scan(target_ip, arguments='-sS -sV -O --top-ports 100')

            for host in nm.all_hosts():
                scan_results['host'].append(host)
                scan_results['status'].append(nm[host].state())
                hostname = nm[host].hostname()
                scan_results['os'].append(nm[host].hostname() if nm[host].hostname() else "N/A")

                result_text.insert(tk.END, f"\nHost: {host} ({hostname})\n")
                result_text.insert(tk.END, f"Status: {nm[host].state()}\n")

                # OS Detection
                if 'osclass' in nm[host]:
                    result_text.insert(tk.END, "\nDevice Information:\n")
                    os_info = []
                    for osclass in nm[host]['osclass']:
                        os_details = (
                            f"OS Family: {osclass.get('osfamily', 'N/A')}\n"
                            f"OS Generation: {osclass.get('osgen', 'N/A')}\n"
                            f"Device Type: {osclass.get('type', 'N/A')}\n"
                            f"Vendor: {osclass.get('vendor', 'N/A')}\n"
                        )
                        os_info.append(os_details)
                        result_text.insert(tk.END, os_details)
                    scan_results['os'][-1] = "\n".join(os_info)
                else:
                    result_text.insert(tk.END, "No OS or device information detected.\n")
                    scan_results['os'].append("No OS information detected.")

                # Protocols and Ports
                protocols = nm[host].all_protocols()
                scan_results['protocols'].append(", ".join(protocols))
                for proto in protocols:
                    result_text.insert(tk.END, f"\nProtocol: {proto}\n")
                    ports = nm[host][proto].keys()
                    port_details = []
                    for port in ports:
                        port_info = nm[host][proto][port]
                        port_detail = f"Port: {port}\tState: {port_info['state']}\tService: {port_info['name']}\tVersion: {port_info.get('version', 'N/A')}\n"
                        port_details.append(port_detail)
                        result_text.insert(tk.END, port_detail)
                    scan_results['ports'].append("\n".join(port_details))

        # Analyze scan results for vulnerabilities
        vulnerabilities = analyze_results(scan_results)
        if vulnerabilities:
            result_text.insert(tk.END, "\nVulnerabilities Detected:\n")
            for vuln in vulnerabilities:
                result_text.insert(tk.END, f"Host: {vuln['host']}\tPort: {vuln['port']}\tIssue: {vuln['issue']}\n")
            # Send notification about vulnerabilities
            notify_user(vulnerabilities)
        else:
            result_text.insert(tk.END, "\nNo common vulnerabilities detected based on open ports.\n")
            # Send notification about scan completion
            notify_user_scan_complete(ip_range)

        # Prompt to save results
        save_results(ip_range, scan_results)

    except Exception as e:
        result_text.insert(tk.END, f"An error occurred: {e}\n")

def analyze_results(scan_results):
    vulnerabilities = []
    # Example vulnerability checks
    vulnerable_ports = {22: "SSH - Potential for brute-force attacks", 
                        80: "HTTP - Possible outdated web server",
                        443: "HTTPS - Ensure SSL/TLS configurations are secure",
                        3306: "MySQL - Ensure strong passwords and updated versions"}

    for i in range(len(scan_results['host'])):
        ports = scan_results['ports'][i].split('\n')
        for port_info in ports:
            if port_info:
                try:
                    port = int(port_info.split('\t')[0].split(':')[1])
                    if port in vulnerable_ports:
                        vulnerabilities.append({
                            'host': scan_results['host'][i],
                            'port': port,
                            'issue': vulnerable_ports[port]
                        })
                except (IndexError, ValueError):
                    continue

    return vulnerabilities

def notify_user(vulnerabilities):
    vuln_messages = [f"Host: {vuln['host']} Port: {vuln['port']} Issue: {vuln['issue']}" for vuln in vulnerabilities]
    vuln_text = "\n".join(vuln_messages)
    notification.notify(
        title="Vulnerability Scanner Alert",
        message=f"Vulnerabilities Detected:\n{vuln_text}",
        timeout=10  # seconds
    )

def notify_user_scan_complete(target_ip):
    notification.notify(
        title="Vulnerability Scanner",
        message=f"Scan completed for {target_ip}. No common vulnerabilities detected.",
        timeout=5  # seconds
    )

def save_results(target_ip, scan_results):
    # Ask user if they want to save the results
    save = messagebox.askyesno("Save Results", "Do you want to save the scan results?")
    if save:
        # Open a file dialog to choose save location
        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Save Scan Results"
        )
        if file_path:
            try:
                with open(file_path, mode='w', newline='', encoding='utf-8') as file:
                    writer = csv.writer(file)
                    # Write headers
                    writer.writerow(["Timestamp", "Target IP", "Host", "Status", "OS Information", "Protocols", "Ports"])
                    
                    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    
                    for i in range(len(scan_results['host'])):
                        writer.writerow([
                            timestamp,
                            target_ip,
                            scan_results['host'][i],
                            scan_results['status'][i],
                            scan_results['os'][i],
                            scan_results['protocols'][i],
                            scan_results['ports'][i]
                        ])
                messagebox.showinfo("Success", f"Scan results saved to {file_path}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to save results: {e}")

def schedule_scan():
    interval = interval_entry.get().strip()
    if not interval.isdigit() or int(interval) <= 0:
        messagebox.showerror("Invalid Interval", "Please enter a valid positive number for the interval.")
        return

    interval_seconds = int(interval)
    ip_range = ip_entry.get().strip()

    if not ip_range:
        messagebox.showerror("Invalid IP", "Please enter a valid IP range before scheduling a scan.")
        return

    # Disable the schedule button to prevent multiple schedules
    schedule_button.config(state=tk.DISABLED)
    cancel_button.config(state=tk.NORMAL)

    # Start the scheduling in a separate thread
    def run_scheduled_scans():
        while not stop_event.is_set():
            scan_target()
            # Wait for the specified interval or until stopped
            for _ in range(interval_seconds):
                if stop_event.is_set():
                    break
                time.sleep(1)

    global stop_event
    stop_event = threading.Event()
    scan_thread = threading.Thread(target=run_scheduled_scans, daemon=True)
    scan_thread.start()

    result_text.insert(tk.END, f"\nScheduled scans every {interval_seconds} seconds.\n")

def cancel_scheduled_scan():
    stop_event.set()
    schedule_button.config(state=tk.NORMAL)
    cancel_button.config(state=tk.DISABLED)
    result_text.insert(tk.END, "\nScheduled scans have been canceled.\n")

# Creating the Tkinter GUI window
root = tk.Tk()
root.title("Vulnerability Scanner")
root.geometry("800x600")

# Adding label and input field for the IP address
ip_label = tk.Label(root, text="Target IP Range (CIDR notation):")
ip_label.pack(pady=5)
ip_entry = tk.Entry(root, width=50)
ip_entry.pack(pady=5)

# Adding label and input field for scan interval
interval_label = tk.Label(root, text="Scan Interval (seconds):")
interval_label.pack(pady=5)
interval_entry = tk.Entry(root, width=20)
interval_entry.pack(pady=5)

# Adding buttons to start and cancel scheduled scans
scan_button = tk.Button(root, text="Start Scan", command=scan_target)
scan_button.pack(pady=10)

schedule_button = tk.Button(root, text="Schedule Scans", command=schedule_scan)
schedule_button.pack(pady=5)

cancel_button = tk.Button(root, text="Cancel Scheduled Scans", command=cancel_scheduled_scan, state=tk.DISABLED)
cancel_button.pack(pady=5)

# Adding a scrollable text area to display results
result_text = scrolledtext.ScrolledText(root, width=100, height=25)
result_text.pack(pady=10)

# Running the Tkinter main loop
root.mainloop()
